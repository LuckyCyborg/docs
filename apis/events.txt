# Events

The idea behind Events is the ability to send data, as parameters, to interested Listeners and call them when an Event happens. The Listeners could be a Closure or a static Class Method.

To note that if the **Events\Dispatcher** does not instantiate a Listener's Class, then the called method must be static.

Its usage is simple; first, we have to register a Listener, adding:

{line-numbers=off}
~~~~~~~~
use Event;

// Add a Listener to the Event 'test'.
Event::listen('test', 'App\Events\Test@handle');
~~~~~~~~

Where the class **App\Events\Test** is

{line-numbers=off}
~~~~~~~~
namespace App\Events;

class Test
{
    public static function handle($message)
    {
        echo $message;
    }
}
~~~~~~~~

Then, when the payload is needed, we would fire the Event:

{line-numbers=off}
~~~~~~~~
// Prepare the Event payload.
$payload = array(
    'Hello, this is an Event!',
);

// Fire the Event 'test'.
Event::fire('test', $payload);
~~~~~~~~

## Queued Events

The Queued Events is a method to add a number of Events to a Queue, then firing them together, flushing the Queue. E.g

{line-numbers=off}
~~~~~~~~
// Queue the Events
Event::queue('test', array('This is the First Event'));
Event::queue('test', array('This is the Second Event'));
Event::queue('test', array('This is the Third Event'));

// Flush the Queue, firing all defined Events
Event::flush('test');
~~~~~~~~

### until() Method

The new method **Events\Dispatcher@until** is about not firing an Event until the first Listener returns a valid and non-null response.

Its usage is simple:

{line-numbers=off}
~~~~~~~~
$response = Event::until('testing', $payload);

if($response !== null) {
    // Do something with $response
}
~~~~~~~~
